1.Следует использовать свойство БлокироватьДляИзменения только при выполнении всех 3 условий: 
Используется новая методика контроля остатков 
У регистра включено разделение итогов 
Используется управляемый режим блокировок.

В форме документа не выведен доступ к регистрам
 Это "Запрос.УстановитьПараметр("МоментВремени", МоментВремени());" заменить на это "Запрос.УстановитьПараметр("МоментВремени", ?(РежимПроведения = РежимПроведенияДокумента.Оперативный, Неопределено, МоментВремени()));" 
 - нужна "защита от копеек", 1С рекомендует делать это вот так: 
 Если КСписанию = ДетальнаяВыборка.Остаток Тогда 
     Стоимость = ДетальнаяВыборка.СуммаОстатка; 
 Иначе 
     Стоимость = КСписанию * ДетальнаяВыборка.СуммаОстатка / ДетальнаяВыборка.Остаток; 
 КонецЕсли; 


2.Как быстро набрать текст управляемой блокировки: 

 1. Вводим в модуле текст "БлокировкаДанных" 
 2. Выделяем, Ctrl+F1, открывается синтаксис-помочник 
 3. Выделяем пример , мышкой перемещаем текст в модуль ( Drag&Drop) 
 4. Переименовуем регистр, удаляем лишние строки и т.д. 
 5. PROFIT 

 Все делается за 30 сек. 

 Как быстро создать подсистемы: 

 1. Выделяем "Общие картинки" ( корень ) 
 2. Drag&Drop мышкой на подсистемы 
 3. PROFIT

3.советую тебе товарища sv_mikh его решения

4. Задача решается на двух регистрах: остатки: Номенклатура Партия Количество Стоимость и обороты: Номенклатура Количество Сумма

 1) если сначала читаем данные из регистра, то нужно использовать объект "Блокировка Данных" 
 2) если сначала пишем записи в регистр, а потом анализируем регистр - можно использовать "Блокировать изменения" - далее система сама поймёт, что и когда ей нужно заблокировать в регистре

Себестоимость   = СписываемоеКоличествоВПартии / ВыборкаДетальныеЗаписи.КоличествоОстаток 
 * ВыборкаДетальныеЗаписи.СуммаОстаток; 
 надо: СписываемоеКоличествоВПартии * ВыборкаДетальныеЗаписи.СуммаОстаток / ВыборкаДетальныеЗаписи.КоличествоОстаток; 
 деление всегда в конце! 

2. Умножение может быть в конце, только если (как написано у тебя) сначала идет Списываем/Выборка.КоличествоОстаток тут нет ошибки. 
 Но надежнее действительно выносить деление в конец. А еще экзаменаторам почему то больше нравится ?(Списываем = Выборка.КоличествоОстаток, Выборка.СуммаОстаток, Выборка.СуммаОстаток/Выборка.КоличествоОстаток*Списываем) 
Самое главное не то, что умножение в конце, а то что в начале деление количеств. По сути это тоже самое что и 
 ?(Списываем = Выборка.КоличествоОстаток, Выборка.СуммаОстаток, Выборка.СуммаОстаток/Выборка.КоличествоОстаток*Списываем) 
 только компактнее. Думаю что при выборе способа с конструкцией ?(,,) экзаменатор сразу видит, что экзаменуемый в теме проблемы копеек и не задает дополнительных вопросов


По поводу "очистки движений" перед проведением. 

 Что происходит при выполнении такого кода? 
 
Code
Движения.ОстаткиНоменклатуры.Очистить();  
 Движения.ОстаткиНоменклатуры.Записать();


 Первая строка очищает набор записей по реристру ОстаткиНоменклатуры. Набор записей - это такая табличка в оперативной памяти. Очстить набор записей - значит удалить все строки таблички в оперативной памяти. В базе данных при этом ничего не меняется, как были старые движения в регистре, так и остались. 

 Вторая строчка записывает набор записей в регистр. Если записываемый набор пуст, происходит очистка движений в базе данных. Если записываемый набор содержит строки, происходит перезапись движений. 

 Выполнение этих двух строк гаратнировано очистит движения в регистре. НО! В начале обработки проведения наборы записей, содержащиеся в коллекции Движения, пустые. Они не содержат строк, пока мы сами туда строки не добавим ниже в алгоритме. Поэтому для очистки движений достаточно просто записать набор записей (выполнить только вторую строку), очищать набор не нунжно, он и так пуст. 

 Можете в отладке запуститься и посмотреть что наборы записей Пустые в начале обработки проведения.

Движения.ОстаткиНоменклатуры.Записать(); так очищают движения регистра, попробуй не писать этого и перепровести там где списывается в ноль где есть контроль остатков 
 можешь не писать этого тогда просто бери остатки не на МоментВремени а делаи границу Невключая 

 Движения.ОстаткиНоменклатуры.Записывать = Истина; это инструкция чтоб все сделанные движения Движения.ОстаткиНоменклатуры.Добавить() записались после выхода из транзакции 

 Движения.ОстаткиНоменклатуры.Очистить(); 
 Движения.ОстаткиНоменклатуры.Записать(); 

 так делают обычно после предварительных расчетов, но в основном в Расчетах, очищают то что запихали для расчета и записывают, погляди тут задачи где необходимо предоставить пользователю исправлять результат руками 